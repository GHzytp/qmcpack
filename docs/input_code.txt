.. _modernize_input_code:

Modernized Input
----------------

Input Facts
~~~~~~~~~~~
- The user supplied input to QMCPACK can be formally thought of as a tree constructed of input nodes. These nodes have optional attributes and content. Content may be nothing, free form "text" that must be handled in an application defined manner, or one or more nodes with the same possible structure.
  For most input classes the child nodes will consist primarily or entirely of ``parameter`` nodes.

- For historical reasons this tree is expressed by using XML as described previously in this manual.
  That documentation is the most formal specification of the input.

- Parameter nodes for historical reasons can be specified in two different ways.

.. code:: xml

     <the_parameters_name attributes....>content</the_parameters_name>
     <parameter name="the_parameters_name"...>content</parameter>  


Input Problems
~~~~~~~~~~~~~~
- The input parsing takes place throughout the execution of the application as needed through `put`, `process` and other calls to existing objects.
- Most/All simulation objects are not valid at construction but are state machines (see :numref:`fig28`) that require many transforms to become valid.
- This makes unit tests difficult since discovering how to creating a valid object requires significant effort, sometimes archeological!
- Reasoning about the state of objects when debugging or developing new features is difficult.
- Attributes are sometimes the main content and not additional information about the "content" of the node.
- In different input sections different ways to specify very similar information. i.e. grids. are used.
- Specific implementations are tangled up in the extended construction of numerous simulation objects and particular input expressions.
- The XML parser catches only the most basic issues with the input document.
- Unrecognized elements, parameter names, and attributes are silently ignored. Sometimes defaults are used instead.
- Invalid input to recognized elements is sometimes checked, sometimes causes crashes, sometimes causes invalid answers (NaNs etc.) and sometimes is just fixed.

  .. _fig28:
.. figure:: /figs/simulation_object_state.png
  :width: 500
  :align: left

  **Simulation object state diagram** emphasizing the long period and multiple state updates required to become a valid object. Many objects
  require more than two updates to go from constructed to valid.

Input Goals
~~~~~~~~~~~

Legacy QMCPACK input parsing is characterized by a unclear ownership of input nodes and a multistage mixture of construction, parsing, validation, and state progression of simulation objects. The handling of input and its relation to testing and error handling is a major pain point for developers. The following program is proposed:

- *Simulation classes* and the input parsing and storage of input values should be refactored into 2 or more classes. Refered to after as *Simulation classes* and *Input classes*.
- No input parsing should occur in *simulation* objects. i.e. no ``put`` methods no ``XMLNodePtr`` argument types. 
- *Simulation* objects should access input parameters as clearly defined and appropriate types through readonly *Input* object accessors, they should not make local copies of these parameters.
- Each type of Node in the input tree should have a clear relationship to some `input` class.
- If an input class is given a node it must be able handle all content and attributes and able to handle or delegate all child nodes.
- Anything other than white space in a node, attribute or element not consumed by the node owner or its delgates constitutes a fatal error.
- The `Input` objects should be for practical purposes immutable after parsing.
- After parsing the input parameters should be in appropriate native c++ types.
- Default values should be specified in native c++ whenever practical.
- In principle you should be able to construct an input object simply by intializing its members i.e. no input parsing necessary.
  
The Improved Input Design
~~~~~~~~~~~~~~~~~~~~~~~~~

1. Make input parsing and validation (to the degree feasible) a distinct stages of application execution.

This will improve separation of concerns, facilitate unit testing,  and allow parsing and validation of input to be completed before the beginning of the simulation proper and the majority of the computation resource cost is incurred.

2. *Simulation* objects take valid *Input* objects as constructor arguements.

If we can assume a one to one relationship between some input node and a simulation object then at its simplest the ``Input`` class for a particular simulation object should be a data structure containing as members native data types corresponding to the possible user input for that node.

3. *Simulation* object will be required to be valid at construction whenever possible.

4. Where input parameters from another simulation object are required carefully consider lifetimes, case by case determine whether it is more appropriate for the simulation object, a more restricted type,  or an input object as a constructor argument.

A base class ``InputSection`` allowing the specification of the user input and handling most parsing of the (currently) XML input is supplied. Composing a type derived from ``InputSection`` is strongly suggested and the rest of this documentation assumes that route is being taken. The basic class hierarchy this results in is illustrated in (see :numref:`fig31`).

.. _fig31:
.. figure:: /uml/SimpleInputClass.png
  :width: 500
  :align: left

  "Modern" input scheme low level class diagram. Simulation class ``SimpleSimObject``, takes input class ``SimpleInput`` as a constructor argument, in general sharing a aggregate relationship.  ``SimpleInput`` composes an input section class ``SimpleInputSection`` derived from ``InputSection`` base class. ``SimpleInput`` gains input parsing functionality from ``SimpleInputSection``.

How to use the Improved Input Design
~~~~~~~~~~~~~~~~~~~~~~~~~

- Determine for your simulation object what are the immutable parameters that are read from or
  directly derived from user input. Your input class is a data structure collecting all the arguments
  your simulation class needs to be constructed in a valid state.
  
- If your simulation class is called ``MySimObject`` name the input class ``MySimObjectInput.``
  - Add a constructor that takes an xmlNodePtr as an argument.  
  - Add data members for each element of the input. If the data type for an input is a ``Position`` it should be represented as a ``Position`` in
  the input class, not a string or other type to be processed further in ``MySimObject``
  
- Derive a class from ``InputSection`` and add it to your ``MySimObjectInput`` class. Here we'll call it ``MySimObjectInputSection``

- Define your user input in ``MySimObjectInputSection``'s default constructor. Default the copy constructor.
  (This is to allow parent Input classes to include this input class in std::variants of their child input classes)

- Add a private data member for the your input section to ``MySimObjectInput`` call it ``input_section_``

- Make an implementation file if you have not, ``MySimObjectInput.cpp``.
- In your ``MySimObjectInput::MySimObjectInput(xmlNodePtr& cur)`` call ``input_section_.readXML(cur)`` to parse input.
- In your constructor use the ``LAMBDA_setIfInInput`` macro to copy ``MyInputSection`` variables if read to your native data members. (see listing),
  the macro generated lambda is strongly typed.

.. code:: c++

	  class MySimObjectInput
	  {
            input_section_.readXML(cur);
	    auto setIfInInput = LAMBDA_setIfInInput;
	    setIfInInput(energy_matrix_, "energy_matrix");
	    ...
	  }



Special concerns if your InputClass is for an Estimator
.......................................................

Estimators are runtime selected objects managed by the ``EstimatorManagerNew`` and their inputs are similarly handled by the ``EstimatorManagerInput`` object. The ``EstimatorManagerInput`` delegates particular child nodes of input to a compile known set of classes.  Your class will be one below we'll assume its named ``MyEstimator.``

This requires that in addtion to creating and unit testing ``MyEstimatorInput`` as explained above you also need to integrate it with ``EstimatorManagerInput`` which is its parent in the native input structure of QMCPACK.

- Add your input classes header to ``EstimatorInputDelegates.h``, this makes its definition visible to compilation units that need to be able to use ``EstimatorInput`` as a complete type.

.. warning::

   Do not include ``EstimatorInputDelegates.h`` file in ``MyEstimatorInput.cpp`` or ``MyEstimator.cpp`` include ``MyEstimatorInput.h`` directly.

Advanced Features of ``InputSection``
.....................................
