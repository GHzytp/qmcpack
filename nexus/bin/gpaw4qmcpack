#!/usr/bin/env python3

from gpaw import restart,setup_paths
from gpaw import __version__ as gpaw_version
from ase.units import Bohr
from numpy import array,pi,dot,real,imag,concatenate,unique,zeros

# define dtypes for the HDF5
int_dtype   = '<i4' # default integer dtype
str_dtype   = 'S'   # default string dtype
float_dtype = 'f'   # default float dtype

# Calculate vector norm of 2-float representation of a complex vector
def calculate_norm(v):
    return ((v**2).sum())**0.5
#end def

# Helper function (obsolete) to match gvector g in an array of gvectors gset
# and return the value of the associated density coefficients from dset
def match_gv(g,gset,dset):
    g0 = gset[:,0]==g[0]
    g1 = gset[:,1]==g[1]
    g2 = gset[:,2]==g[2]
    return dset[logical_and(logical_and(g0,g1),g2),:][0]
#end def

# Add the negative half of gvectors removed by symmetry (full array expected by QMCPACK)
def desymmetrize_z(gv,psi):
    gv2  = -gv[1:].copy()
    psi2 = psi[1:].copy()
    psi2[:,1] *= -1
    gv2  = concatenate((gv, gv2), axis=0)
    psi2 = concatenate((psi,psi2),axis=0)
    return gv2,psi2
#end def

# WIP: class for an ESHDF file
#   Currently only supports PW mode and reading data from GPAW structures
class ESHDF_file():

    loaded      = False
    version     = [2,1,0]
    fmt         = 'ES-HDF'
    outfile     = 'eshdf.h5'

    # if infile and outfile provided, load automatically
    def __init__(
        self,
        infile    = None,
        outfile   = None,
        **kwargs
        ):
        self.infile  = infile
        self.outfile = outfile
        if infile is not None:
            self.load(infile=infile,**kwargs)
        #end if
    #end def

    # initiate loading of data from the provided objects
    #   Compute and add charge density, if density=True
    def load(
        self,
        infile  = None,
        calc    = None,
        atoms   = None,
        density = False,
        **kwargs,
        ):
        self.density = density
        if infile is not None:
            if '.gpw' in infile:
                self.load_gpaw_restart(infile,**kwargs)
            else:
                print('Unsupported file {} not loaded.'.format(infile))
            #end if
        elif calc is not None and atoms is not None:
            self.load_gpaw_calc(calc,atoms)
        else:
            print('Could not load data for ESHDF.')
        #end if
    #end def

    # load data from GPAW restart file
    def load_gpaw_restart(
        self,
        infile,
        setups  = './', # add setup paths: for testing, defaults to './'
        **kwargs,
        ):
        from gpaw import restart
        # Add a custom setup path before loading GPAW restart file
        if setups is not None:
            from gpaw import setup_paths
            setup_paths.insert(0,setups)
        #end if
        atoms,calc = restart(infile)
        try: # check if the wavefunction exists
            wfs = calc.wfs
        except:
            print('ERROR: No wavefunctions found in the GPAW restart file {}'.format(filename))
            print("Make sure to write the GPAW file with mode='all'!")
            return
        #end try
        if self.density: 
            # run SCF to re-populate density
            print('Running SCF to re-populate density')
            calc.scf.converged = False
            calc.results.pop('energy')
            E = calc.get_potential_energy()
        #end def
        self.load_gpaw_calc(calc,atoms)
    #end def

    # GPAW: load data from calc and atoms objects
    #   Currently only supports PW mode
    def load_gpaw_calc(
        self,
        calc,
        atoms,
        ):
        mode = calc.wfs.mode
        if mode=='pw':
            self._load_application()
            self._load_atoms(calc,atoms)
            self._load_electrons(calc,atoms)
        else:
            print('Could not load data from GPAW Calculator in mode={}. Only pw mode is currently supported.'.format(mode))
        #end if
        self.loaded = True
    #end def

    # GPAW: load "application" data
    def _load_application(self):
        from gpaw import __version__ as gpaw_version
        from re import sub
        self.application = 'gpaw'
        self.app_version = sub('\D',' ',gpaw_version).split()[:3]
    #end def

    # GPAW: load "atoms" data
    def _load_atoms(self,calc,atoms):
        num_atoms = atoms.get_global_number_of_atoms()
        supercell = calc.wfs.gd.cell_cv
        syms      = atoms.get_chemical_symbols()
        masses    = atoms.get_masses()
        positions = atoms.get_positions()/Bohr # convert from A to Bohr
        Zs        = atoms.get_atomic_numbers()
        # figure out species data
        sym_set         = set(syms)
        num_species     = len(sym_set)
        species_ids     = []
        species_mass    = []
        species_Z       = []
        species_name    = []
        species_valence = []
        for s,name in enumerate(sym_set):
            i = syms.index(name)
            species_mass.append(masses[i])
            species_Z.append(Zs[i])
            species_valence.append(Zs[i]) # fixme for PP calculations
            species_name.append(name)
            for sym in syms:
                if sym==name:
                    species_ids.append(s)
                #end if
            #end for
        #end for
        self.species         = sym_set
        self.num_species     = num_species
        self.num_atoms       = num_atoms
        self.positions       = positions
        self.species_ids     = species_ids
        self.species_mass    = species_mass
        self.species_valence = species_valence
        self.species_Z       = species_Z
        self.species_name    = species_name
        self.supercell       = supercell
    #end def

    # GPAW: transform reciprocal vectors to Miller indices
    def _get_pw_indices(self,pd,k):
        return array(dot(pd.get_reciprocal_vectors(k,add_q=False),pd.gd.cell_cv/2/pi).round(0),dtype=int)
    #end def

    # GPAW: load "electrons" data
    def _load_electrons(self,calc,atoms):
        mesh     = calc.wfs.gd.N_c
        num_spin = calc.wfs.nspins
        N_tot    = calc.wfs.nvalence
        if num_spin==1:
            N_up = N_tot // 2
            N_dn = N_tot - N_up
        else: # spin-polarized # FIXME
            N_up = N_tot // 2
            N_dn = N_tot - N_up
        #end if
        # kpoints
        num_kpt  = calc.wfs.kd.get_count()
        W_kpt    = calc.wfs.kd.weight_k
        try:
            kpts    = calc.wfs.kd.get_bz_q_points()
        except:
            kpts    = calc.wfs.kd.bzk_kc
        #end try

        # Combine the GPAW plane wave data for each separate kpoint into one big array, gvall
        gvall = self._get_pw_indices(calc.wfs.pd,0)
        imin  = 0
        imax  = len(gvall)
        iis   = [[imin,imax]] # indices to mark the beginning and end of each kpoint
        for k in range(1,num_kpt):
            gv    = self._get_pw_indices(calc.wfs.pd,k)
            gvall = concatenate((gvall,gv),axis=0)
            imin  = imax
            imax += len(gv)
            iis.append([imin,imax])
        #end for
        # Gv is a new gvector basis with only unique vectors
        # indices help to associate the pw correct coefficients later on
        Gv,indices = unique(gvall,axis=0,return_inverse=True)

        data_numsym     = []
        data_symgroup   = []
        data_reduced_k  = []
        data_occupation = []
        data_num_bands  = []
        data_eps        = []
        data_psi_g      = []
        for k,kpt in enumerate(kpts):
            numsym = 1   # FIXME
            symgroup = 1 # FIXME
            data_numsym.append(numsym)
            data_symgroup.append(symgroup)
            ii = iis[k]
            # TODO: checks for spin polarized calculations?
            datas_eps       = []
            datas_psi_g     = []
            datas_num_bands = []
            for s in range(num_spin):
                occ       = calc.wfs.kpt_u[k].f_n
                eps       = calc.wfs.kpt_u[k].eps_n
                num_bands = len(eps)
                u         = k*num_spin+s
                datasn_psi_g = []
                for n in range(num_bands):
                    # get wavefunction in PW
                    wf_c  = calc.wfs.kpt_u[u].psit_nG[n]
                    wf    = array([real(wf_c),imag(wf_c)])
                    psi   = zeros((len(Gv),2))
                    psi[indices[ii[0]:ii[1]]] = wf.T/calculate_norm(wf) # normalize the crude way
                    datasn_psi_g.append(psi)
                #end for
                datas_num_bands.append(num_bands)
                datas_eps.append(eps)
                datas_psi_g.append(datasn_psi_g)
            #end for
            data_eps.append(datas_eps)
            data_num_bands.append(datas_num_bands)
            data_psi_g.append(datas_psi_g)
        #end for
        self.gvectors   = Gv
        self.num_elec   = [N_up,N_dn]
        self.kpts       = kpts
        self.numsym     = data_numsym
        self.symgroup   = data_symgroup
        self.reduced_k  = data_reduced_k
        self.W_kpt      = W_kpt
        self.num_bands  = data_num_bands
        self.num_spin   = num_spin
        self.eps        = data_eps
        self.psi_g      = data_psi_g
        if self.density:
            # FIXME: spin polarized
            # read data
            rho_gv   = self._get_pw_indices(calc.density.pd2,0)
            rho_psic = calc.density.nt_Q
            # process
            rho_psi  = array([real(rho_psic),imag(rho_psic)]).T
            gv,rho   = desymmetrize_z(rho_gv,rho_psi)
            n        = N_tot/rho[0,0]/calc.density.gd.volume # normalize at the gamma point
            # save
            self.rho_gv   = gv
            self.rho_g    = rho*n
        #end if
    #end def

    # write the data to an HDF5 file
    def write(self, outfile = None):
        if not self.loaded:
            print('Must load data from a file or GPAW calculator objects before writing!')
            return
        #end if
        if outfile is None:
            outfile = self.outfile
        #end if
        import h5py as h5
        with h5.File(outfile,mode='w') as f:
            self._write_application(f)
            self._write_atoms(f)
            self._write_electrons(f)
            self._write_format(f)
            self._write_supercell(f)
            self._write_version(f)
        #end with
    #end def

    def _write_application(self,f):
        g = f.create_group('application')
        g.create_dataset('code',shape=1,data=array(self.application,dtype=str_dtype))
        g.create_dataset('version',shape=3,data=array(self.app_version,dtype=int_dtype))
    #end def

    def _write_atoms(self,f):
        g  = f.create_group('atoms')
        g.create_dataset('number_of_atoms',data=array([self.num_atoms],dtype=int_dtype))
        g.create_dataset('number_of_species',data=array([self.num_spin],dtype=int_dtype))
        g.create_dataset('positions',data=self.positions)
        for s,sid in enumerate(self.species):
            gs = g.create_group('species_'+str(s))
            gs.create_dataset('atomic_number',data=array([self.species_Z[s]]),dtype=int_dtype)
            gs.create_dataset('mass',data=array([self.species_mass[s]],dtype=float_dtype))
            gs.create_dataset('name',data=array([self.species_name[s]],dtype=str_dtype))
            gs.create_dataset('valence_charge',data=array([self.species_valence[s]],dtype=float_dtype))
        #end for
        g.create_dataset('species_ids',data=array(self.species_ids),dtype=int_dtype)
    #end def

    def _write_electrons(self,f):
        g = f.create_group('electrons')
        if self.density:
            gd = g.create_group('density')
            gd.create_dataset('gvectors',data=self.rho_gv)
            gd.create_dataset('number_of_gvectors',data=array([self.rho_gv.shape[0]],dtype=int_dtype))
            for s in range(self.num_spin):
                gd0 = gd.create_group('spin_0')
                gd0.create_dataset('density_g',data=self.rho_g)
            #end for
        #end if
        for k,kpt in enumerate(self.kpts):
            kp0 = g.create_group('kpoint_{}'.format(k))
            if k==0:
                kp0.create_dataset('gvectors',data=self.gvectors)
                kp0.create_dataset('number_of_gvectors',data=array([self.gvectors.shape[0]],dtype=int_dtype))
            #end if
            kp0.create_dataset('numsym',data=array([self.numsym[k]],dtype=int_dtype))
            kp0.create_dataset('reduced_k',data=kpt)
            for s in range(self.num_spin):
                kp00 = kp0.create_group('spin_{}'.format(s))
                kp00.create_dataset('eigenvalues',data=self.eps[k][s])
                kp00.create_dataset('number_of_states',data=array([self.num_bands[k][s]],dtype=int_dtype))
                for n in range(self.num_bands[k][s]):
                    kp00s = kp00.create_group('state_{}'.format(n))
                    kp00s.create_dataset('psi_g',data=self.psi_g[k][s][n])
                #end for
            #end for
            kp0.create_dataset('symgroup',data=array([self.symgroup[k]],dtype=int_dtype))
            kp0.create_dataset('weight',data=array([self.W_kpt[k]],dtype=float_dtype))
        #end for
        g.create_dataset('number_of_electrons',data=self.num_elec)
        g.create_dataset('number_of_kpoints',data=array([len(self.kpts)],dtype=int_dtype))
        g.create_dataset('number_of_spins',data=array([self.num_spin],dtype=int_dtype))
    #end def

    def _write_format(self,f):
        f.create_dataset('format',data=array(self.fmt,dtype=str_dtype))
    #end def

    def _write_supercell(self,f):
        g = f.create_group('supercell')
        g.create_dataset('primitive_vectors',data=self.supercell)
    #end def
    
    def _write_version(self,f):
        f.create_dataset('version',data=array(self.version,dtype=int_dtype))
    #end def

#end class

def print_help_and_exit():
    print('''
Usage:  gpaw4qmcpack [options] INFILE [OUTFILE]

  INFILE  is a .gpw restart file
  OUTFILE is an .h5 orbital file for QMCPACK [default=eshdf.h5]

  options and <arguments> where needed:

    -s <path>     GPAW Setup path for searching UPF files.
                  By default, './' is added.
    -d            Convert charge density data. Default: no.

  TROUBLESHOOTING:

  The GPAW restart file (INFILE) must include 
  
''')
    exit()
#end def

# parse command lines arguments
def parse_args(args):
    if len(args)==1:
        print_help_and_exit()
    #end if
    # parse arguments
    infile_set = False
    options    = {}
    outfile    = 'eshdf.h5'
    i = 1
    while i<len(args):
        arg = args[i]
        if arg=='-s': # setup path
            i += 1
            arg = args[i]
            options['setups'] = arg # test exists
        elif arg=='-d': # density
            options['density'] = True
        elif not infile_set:
            infile = arg
            # check if exists
            infile_set = True
        else:
            outfile = arg
        #end if
        i += 1
    #end while
    return infile,outfile,options
#end def

if __name__=='__main__':
    from sys import argv
    infile,outfile,options = parse_args(argv)
    eshdf = ESHDF_file(infile=infile,outfile=outfile,**options)
    eshdf.write(outfile)
    print('Converted GPAW orbitals for QMCPACK!')
#end if
