#!/usr/bin/env python3

from sys import argv
from gpaw import restart,setup_paths
from gpaw import __version__ as gpaw_version
from numpy import array,pi,dot,real,imag,concatenate,unique,zeros
import h5py as h5

i32le = '<i4' # default integer dtype
h5str = 'S'   # default string dtype
a0    = 0.529177210903

# load gpaw restart file
def load_gpaw_restart(filename):
    atoms,calc = restart(filename)
    # check wfs
    if not 'wfs' in calc.keys():
        print('ERROR: No wavefunctions found in the GPAW restart file {}'.format(filename))
        print("Make sure to write the GPAW file with mode='all'!")
        exit()
    #end if
    return atoms,calc
#end def

# write application
def write_application(f,version='19.1.0'):
    v_ar = array(list(map(int,version.split('.'))),dtype=i32le)
    g = f.create_group('application')
    g.create_dataset('code',shape=1,data=array('gpaw',dtype=h5str))
    g.create_dataset('version',shape=3,data=v_ar)
#end def

# write atoms
def write_atoms(f,atoms):
    Na        = atoms.get_global_number_of_atoms()
    syms      = atoms.get_chemical_symbols()
    masses    = atoms.get_masses()
    positions = atoms.get_positions()/a0 # convert from A to Bohr
    Zs        = atoms.get_atomic_numbers()
    sym_set   = set(syms)
    Ns        = len(sym_set)

    species_ids = []
    g  = f.create_group('atoms')
    g.create_dataset('number_of_atoms',shape=1,data=array(Na,dtype=i32le))
    g.create_dataset('number_of_species',shape=1,data=array(Ns,dtype=i32le))
    g.create_dataset('positions',shape=positions.shape,data=positions)
    for s,name in enumerate(sym_set):
        i       = syms.index(name)
        mass    = masses[i]
        Z       = Zs[i]
        Zeff    = Z # fixme for PP calculations
        for sym in syms:
            if sym==name:
                species_ids.append(s)
            #end if
        #end for
        gs = g.create_group('species_'+str(s))
        gs.create_dataset('atomic_number',shape=1,data=Z)
        gs.create_dataset('mass',shape=1,data=mass)
        gs.create_dataset('name',shape=1,data=name)
        gs.create_dataset('valence_charge',shape=1,data=Zeff)
    #end for
    g.create_dataset('species_ids',shape=len(species_ids),data=species_ids)
#end def


# figure out number of up/dn electrons
def get_num_electrons(calc,N_spin=1):
    N_tot = calc.wfs.nvalence
    if N_spin==1:
        N_up = N_tot // 2
        N_dn = N_tot - N_up
    else: # spin-polarized # FIXME
        N_up = N_tot // 2
        N_dn = N_tot - N_up
    #end if
    return array([N_up,N_dn],dtype='i4')
#end def

def calculate_norm(v):
    return ((v**2).sum())**0.5
#end def

def add_setup_path(setup_path):
    setup_paths.insert(0,setup_path)
#end def

# write electrons
def write_electrons(f,atoms,calc):
    mesh     = calc.wfs.gd.N_c
    N_spin   = calc.wfs.nspins
    N_elec   = get_num_electrons(calc,N_spin)
    periodic = any(atoms.pbc)
    # kpoints
    N_kpt   = calc.wfs.kd.get_count()
    Ws      = calc.wfs.kd.weight_k
    try:
        kpts    = calc.wfs.kd.get_bz_q_points()
    except:
        kpts    = calc.wfs.kd.bzk_kc
    #end try

    g = f.create_group('electrons')
    # density # FIXME
    #Gv       = array(dot(calc.wfs.pd.get_reciprocal_vectors(),calc.wfs.gd.cell_cv/2/pi).round(0),dtype=int)
    #N_g      = calc.wfs.pd.ng_q[0] # FIXME
    #gd = g.create_group('density')
    #gd.create_dataset('gvectors',shape=Gv.shape,data=Gv)
    #gd.create_dataset('mesh',shape=3,data=mesh)
    #gd.create_dataset('number_of_gvectors',shape=1,data=N_g)
    #for s in range(N_spin):
    #    density_g = calculate_density(calc,s)
    #    gd0 = gd.create_group('spin_{}'.format(s))
    #    gd0.create_dataset('density_g',shape=density_g.shape,data=density_g)
    #end for

    # calculate all wfs and gvs
    gvall = array(dot(calc.wfs.pd.get_reciprocal_vectors(0,add_q=False),calc.wfs.gd.cell_cv/2/pi).round(0),dtype=int)
    imin  = 0
    imax  = len(gvall)
    iis   = [[imin,imax]]
    for k in range(1,N_kpt):
        gv    = array(dot(calc.wfs.pd.get_reciprocal_vectors(k,add_q=False),calc.wfs.gd.cell_cv/2/pi).round(0),dtype=int)
        gvall = concatenate((gvall,gv),axis=0)
        imin  = imax
        imax += len(gv)
        iis.append([imin,imax])
    #end for
    Gv,indices = unique(gvall,axis=0,return_inverse=True)

    for k,kpt in enumerate(kpts):
        numsym = 1   # FIXME
        symgroup = 1 # FIXME
        #Gv  = array(dot(calc.wfs.pd.get_reciprocal_vectors(k,add_q=False),calc.wfs.gd.cell_cv/2/pi).round(0),dtype=int)
        kp0 = g.create_group('kpoint_{}'.format(k))
        if k==0:
            kp0.create_dataset('gvectors',shape=Gv.shape,data=Gv)
            kp0.create_dataset('number_of_gvectors',data=Gv.shape[0])
        #end if
        kp0.create_dataset('numsym',data=array([numsym],dtype=i32le))
        kp0.create_dataset('reduced_k',shape=len(kpt),data=kpt)
        ii = iis[k]
        # TODO: checks for spin polarized calculations?
        for s in range(N_spin):
            occ    = calc.wfs.kpt_u[k].f_n
            #eps    = calc.wfs.kpt_u[k].eps_n[occ>1e-4] # FIXME
            eps    = calc.wfs.kpt_u[k].eps_n
            N_band = len(eps)
            u      = k*N_spin+s
            kp00 = kp0.create_group('spin_{}'.format(s))
            kp00.create_dataset('eigenvalues',shape=eps.shape,data=eps)
            kp00.create_dataset('number_of_states',data=array([N_band],dtype=i32le))
            for n in range(N_band):
                # get wavefunction in PW
                #wf_c  = calc.wfs.get_wave_function_array(n,k,s,realspace=False,cut=False,periodic=periodic) # leads to wrong dimensions
                wf_c  = calc.wfs.kpt_u[u].psit_nG[n]
                wf    = array([real(wf_c),imag(wf_c)])
                psi   = zeros((len(Gv),2))
                psi[indices[ii[0]:ii[1]]] = wf.T/calculate_norm(wf) # normalize the crude way
                kp00s = kp00.create_group('state_{}'.format(n))
                kp00s.create_dataset('psi_g',shape=psi.shape,data=psi)
            #end for
        #end for
        kp0.create_dataset('symgroup',data=array([symgroup],dtype=i32le))
        kp0.create_dataset('weight',data=array([Ws[k]],dtype=float)) 
    #end for
    g.create_dataset('number_of_electrons',shape=2,data=N_elec)
    g.create_dataset('number_of_kpoints',data=array([N_kpt],dtype=i32le))
    g.create_dataset('number_of_spins',data=array([N_spin],dtype=i32le))
#end def

# write format
def write_format(f):
    f.create_dataset('format',shape=1,data=array('ES-HDF5',dtype=h5str))
#end def

# write supercell
def write_supercell(f,calc):
    cell = calc.wfs.gd.cell_cv
    g = f.create_group('supercell')
    g.create_dataset('primitive_vectors',shape=cell.shape,data=cell)
#end def

# write version
def write_version(f,version=[2,1,0]):
    f.create_dataset('version',shape=3,data=array(version,i32le))
#end def


def print_help_and_exit():
    print('''
Usage:  gpaw4qmcpack [options] INFILE [OUTFILE]

  INFILE  is a .gpw restart file
  OUTFILE is an .h5 orbital file for QMCPACK [default=eshdf.h5]

  options and <arguments> where needed:

    -s <path>     GPAW Setup path for searching UPF files.
                  By default, './' is added.

  TROUBLESHOOTING:

  The GPAW restart file (INFILE) must include 
  
''')
    exit()
#end def

# parse argument
def parse_args(args):
    if len(args)==1:
        print_help_and_exit()
    #end if
    # parse arguments
    infile_set = False
    outfile    = 'eshdf.h5'
    i = 1
    while i<len(args):
        arg = args[i]
        if arg=='-s': # setup path
            i += 1
            arg = args[i]
            add_setup_path(arg)
        elif not infile_set:
            infile = arg
            # check if exists
            infile_set = True
        else:
            outfile = arg
        #end if
        i += 1
    #end while
    return infile,outfile
#end def


if __name__=='__main__':
    infile,outfile = parse_args(argv)
    # for testing, add local directory by default
    add_setup_path('./')
    atoms,calc = load_gpaw_restart(infile)
    with h5.File(outfile,mode='w') as f:
        write_application(f,gpaw_version)
        write_atoms(f,atoms)
        write_electrons(f,atoms,calc)
        write_format(f)
        write_supercell(f,calc)
        write_version(f)
    #end with
#end if

